// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.20.3
// source: codebase_syncer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire"
import {
	type CallOptions,
	type ChannelCredentials,
	Client,
	type ClientOptions,
	type ClientUnaryCall,
	type handleUnaryCall,
	makeGenericClientConstructor,
	type Metadata,
	type ServiceError,
	type UntypedServiceImplementation,
} from "@grpc/grpc-js"
import { Empty } from "./google/protobuf/empty"

export const protobufPackage = "codebase_syncer"

/**
 * Token sharing request (encrypted storage)
 * Share AccessToken request (includes server_endpoint)
 */
export interface ShareAccessTokenRequest {
	/** Client ID */
	clientId: string
	/** Token */
	accessToken: string
	/** Cloud service endpoint */
	serverEndpoint: string
}

/** Share Token response */
export interface ShareAccessTokenResponse {
	success: boolean
	message: string
}

/** Register workspace sync */
export interface RegisterSyncRequest {
	/** Client ID */
	clientId: string
	/** Workspace path */
	workspacePath: string
	/** Workspace name */
	workspaceName: string
}

/** Register workspace sync response */
export interface RegisterSyncResponse {
	/** Whether succeeded */
	success: boolean
	/** Message */
	message: string
}

/** Unregister workspace sync */
export interface UnregisterSyncRequest {
	/** Client ID */
	clientId: string
	/** Workspace path */
	workspacePath: string
	/** Workspace name */
	workspaceName: string
}

/** Version info request */
export interface VersionRequest {
	/** Client ID */
	clientId: string
}

/** Version info response */
export interface VersionResponse {
	/** Whether succeeded */
	success: boolean
	/** Message */
	message: string
	/** Data */
	data: VersionResponse_Data | undefined
}

export interface VersionResponse_Data {
	/** Version number */
	version: string
	/** Application name */
	appName: string
	/** OS name */
	osName: string
	/** Architecture name */
	archName: string
}

function createBaseShareAccessTokenRequest(): ShareAccessTokenRequest {
	return { clientId: "", accessToken: "", serverEndpoint: "" }
}

export const ShareAccessTokenRequest: MessageFns<ShareAccessTokenRequest> = {
	encode(message: ShareAccessTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.clientId !== "") {
			writer.uint32(10).string(message.clientId)
		}
		if (message.accessToken !== "") {
			writer.uint32(18).string(message.accessToken)
		}
		if (message.serverEndpoint !== "") {
			writer.uint32(26).string(message.serverEndpoint)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ShareAccessTokenRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseShareAccessTokenRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.clientId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.accessToken = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.serverEndpoint = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ShareAccessTokenRequest {
		return {
			clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
			accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
			serverEndpoint: isSet(object.serverEndpoint) ? globalThis.String(object.serverEndpoint) : "",
		}
	},

	toJSON(message: ShareAccessTokenRequest): unknown {
		const obj: any = {}
		if (message.clientId !== "") {
			obj.clientId = message.clientId
		}
		if (message.accessToken !== "") {
			obj.accessToken = message.accessToken
		}
		if (message.serverEndpoint !== "") {
			obj.serverEndpoint = message.serverEndpoint
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ShareAccessTokenRequest>, I>>(base?: I): ShareAccessTokenRequest {
		return ShareAccessTokenRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ShareAccessTokenRequest>, I>>(object: I): ShareAccessTokenRequest {
		const message = createBaseShareAccessTokenRequest()
		message.clientId = object.clientId ?? ""
		message.accessToken = object.accessToken ?? ""
		message.serverEndpoint = object.serverEndpoint ?? ""
		return message
	},
}

function createBaseShareAccessTokenResponse(): ShareAccessTokenResponse {
	return { success: false, message: "" }
}

export const ShareAccessTokenResponse: MessageFns<ShareAccessTokenResponse> = {
	encode(message: ShareAccessTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success)
		}
		if (message.message !== "") {
			writer.uint32(18).string(message.message)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ShareAccessTokenResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseShareAccessTokenResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.success = reader.bool()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.message = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ShareAccessTokenResponse {
		return {
			success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
			message: isSet(object.message) ? globalThis.String(object.message) : "",
		}
	},

	toJSON(message: ShareAccessTokenResponse): unknown {
		const obj: any = {}
		if (message.success !== false) {
			obj.success = message.success
		}
		if (message.message !== "") {
			obj.message = message.message
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ShareAccessTokenResponse>, I>>(base?: I): ShareAccessTokenResponse {
		return ShareAccessTokenResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ShareAccessTokenResponse>, I>>(object: I): ShareAccessTokenResponse {
		const message = createBaseShareAccessTokenResponse()
		message.success = object.success ?? false
		message.message = object.message ?? ""
		return message
	},
}

function createBaseRegisterSyncRequest(): RegisterSyncRequest {
	return { clientId: "", workspacePath: "", workspaceName: "" }
}

export const RegisterSyncRequest: MessageFns<RegisterSyncRequest> = {
	encode(message: RegisterSyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.clientId !== "") {
			writer.uint32(10).string(message.clientId)
		}
		if (message.workspacePath !== "") {
			writer.uint32(18).string(message.workspacePath)
		}
		if (message.workspaceName !== "") {
			writer.uint32(26).string(message.workspaceName)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RegisterSyncRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseRegisterSyncRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.clientId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.workspacePath = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.workspaceName = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): RegisterSyncRequest {
		return {
			clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
			workspacePath: isSet(object.workspacePath) ? globalThis.String(object.workspacePath) : "",
			workspaceName: isSet(object.workspaceName) ? globalThis.String(object.workspaceName) : "",
		}
	},

	toJSON(message: RegisterSyncRequest): unknown {
		const obj: any = {}
		if (message.clientId !== "") {
			obj.clientId = message.clientId
		}
		if (message.workspacePath !== "") {
			obj.workspacePath = message.workspacePath
		}
		if (message.workspaceName !== "") {
			obj.workspaceName = message.workspaceName
		}
		return obj
	},

	create<I extends Exact<DeepPartial<RegisterSyncRequest>, I>>(base?: I): RegisterSyncRequest {
		return RegisterSyncRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<RegisterSyncRequest>, I>>(object: I): RegisterSyncRequest {
		const message = createBaseRegisterSyncRequest()
		message.clientId = object.clientId ?? ""
		message.workspacePath = object.workspacePath ?? ""
		message.workspaceName = object.workspaceName ?? ""
		return message
	},
}

function createBaseRegisterSyncResponse(): RegisterSyncResponse {
	return { success: false, message: "" }
}

export const RegisterSyncResponse: MessageFns<RegisterSyncResponse> = {
	encode(message: RegisterSyncResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success)
		}
		if (message.message !== "") {
			writer.uint32(18).string(message.message)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RegisterSyncResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseRegisterSyncResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.success = reader.bool()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.message = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): RegisterSyncResponse {
		return {
			success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
			message: isSet(object.message) ? globalThis.String(object.message) : "",
		}
	},

	toJSON(message: RegisterSyncResponse): unknown {
		const obj: any = {}
		if (message.success !== false) {
			obj.success = message.success
		}
		if (message.message !== "") {
			obj.message = message.message
		}
		return obj
	},

	create<I extends Exact<DeepPartial<RegisterSyncResponse>, I>>(base?: I): RegisterSyncResponse {
		return RegisterSyncResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<RegisterSyncResponse>, I>>(object: I): RegisterSyncResponse {
		const message = createBaseRegisterSyncResponse()
		message.success = object.success ?? false
		message.message = object.message ?? ""
		return message
	},
}

function createBaseUnregisterSyncRequest(): UnregisterSyncRequest {
	return { clientId: "", workspacePath: "", workspaceName: "" }
}

export const UnregisterSyncRequest: MessageFns<UnregisterSyncRequest> = {
	encode(message: UnregisterSyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.clientId !== "") {
			writer.uint32(10).string(message.clientId)
		}
		if (message.workspacePath !== "") {
			writer.uint32(18).string(message.workspacePath)
		}
		if (message.workspaceName !== "") {
			writer.uint32(26).string(message.workspaceName)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UnregisterSyncRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseUnregisterSyncRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.clientId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.workspacePath = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.workspaceName = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): UnregisterSyncRequest {
		return {
			clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
			workspacePath: isSet(object.workspacePath) ? globalThis.String(object.workspacePath) : "",
			workspaceName: isSet(object.workspaceName) ? globalThis.String(object.workspaceName) : "",
		}
	},

	toJSON(message: UnregisterSyncRequest): unknown {
		const obj: any = {}
		if (message.clientId !== "") {
			obj.clientId = message.clientId
		}
		if (message.workspacePath !== "") {
			obj.workspacePath = message.workspacePath
		}
		if (message.workspaceName !== "") {
			obj.workspaceName = message.workspaceName
		}
		return obj
	},

	create<I extends Exact<DeepPartial<UnregisterSyncRequest>, I>>(base?: I): UnregisterSyncRequest {
		return UnregisterSyncRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<UnregisterSyncRequest>, I>>(object: I): UnregisterSyncRequest {
		const message = createBaseUnregisterSyncRequest()
		message.clientId = object.clientId ?? ""
		message.workspacePath = object.workspacePath ?? ""
		message.workspaceName = object.workspaceName ?? ""
		return message
	},
}

function createBaseVersionRequest(): VersionRequest {
	return { clientId: "" }
}

export const VersionRequest: MessageFns<VersionRequest> = {
	encode(message: VersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.clientId !== "") {
			writer.uint32(10).string(message.clientId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): VersionRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseVersionRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.clientId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): VersionRequest {
		return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" }
	},

	toJSON(message: VersionRequest): unknown {
		const obj: any = {}
		if (message.clientId !== "") {
			obj.clientId = message.clientId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<VersionRequest>, I>>(base?: I): VersionRequest {
		return VersionRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<VersionRequest>, I>>(object: I): VersionRequest {
		const message = createBaseVersionRequest()
		message.clientId = object.clientId ?? ""
		return message
	},
}

function createBaseVersionResponse(): VersionResponse {
	return { success: false, message: "", data: undefined }
}

export const VersionResponse: MessageFns<VersionResponse> = {
	encode(message: VersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success)
		}
		if (message.message !== "") {
			writer.uint32(18).string(message.message)
		}
		if (message.data !== undefined) {
			VersionResponse_Data.encode(message.data, writer.uint32(26).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): VersionResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseVersionResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.success = reader.bool()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.message = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.data = VersionResponse_Data.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): VersionResponse {
		return {
			success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
			message: isSet(object.message) ? globalThis.String(object.message) : "",
			data: isSet(object.data) ? VersionResponse_Data.fromJSON(object.data) : undefined,
		}
	},

	toJSON(message: VersionResponse): unknown {
		const obj: any = {}
		if (message.success !== false) {
			obj.success = message.success
		}
		if (message.message !== "") {
			obj.message = message.message
		}
		if (message.data !== undefined) {
			obj.data = VersionResponse_Data.toJSON(message.data)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<VersionResponse>, I>>(base?: I): VersionResponse {
		return VersionResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<VersionResponse>, I>>(object: I): VersionResponse {
		const message = createBaseVersionResponse()
		message.success = object.success ?? false
		message.message = object.message ?? ""
		message.data =
			object.data !== undefined && object.data !== null
				? VersionResponse_Data.fromPartial(object.data)
				: undefined
		return message
	},
}

function createBaseVersionResponse_Data(): VersionResponse_Data {
	return { version: "", appName: "", osName: "", archName: "" }
}

export const VersionResponse_Data: MessageFns<VersionResponse_Data> = {
	encode(message: VersionResponse_Data, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.version !== "") {
			writer.uint32(10).string(message.version)
		}
		if (message.appName !== "") {
			writer.uint32(18).string(message.appName)
		}
		if (message.osName !== "") {
			writer.uint32(26).string(message.osName)
		}
		if (message.archName !== "") {
			writer.uint32(34).string(message.archName)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): VersionResponse_Data {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseVersionResponse_Data()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.version = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.appName = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.osName = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.archName = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): VersionResponse_Data {
		return {
			version: isSet(object.version) ? globalThis.String(object.version) : "",
			appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
			osName: isSet(object.osName) ? globalThis.String(object.osName) : "",
			archName: isSet(object.archName) ? globalThis.String(object.archName) : "",
		}
	},

	toJSON(message: VersionResponse_Data): unknown {
		const obj: any = {}
		if (message.version !== "") {
			obj.version = message.version
		}
		if (message.appName !== "") {
			obj.appName = message.appName
		}
		if (message.osName !== "") {
			obj.osName = message.osName
		}
		if (message.archName !== "") {
			obj.archName = message.archName
		}
		return obj
	},

	create<I extends Exact<DeepPartial<VersionResponse_Data>, I>>(base?: I): VersionResponse_Data {
		return VersionResponse_Data.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<VersionResponse_Data>, I>>(object: I): VersionResponse_Data {
		const message = createBaseVersionResponse_Data()
		message.version = object.version ?? ""
		message.appName = object.appName ?? ""
		message.osName = object.osName ?? ""
		message.archName = object.archName ?? ""
		return message
	},
}

/** Sync service definition */
export type SyncServiceService = typeof SyncServiceService
export const SyncServiceService = {
	/** Register project sync */
	registerSync: {
		path: "/codebase_syncer.SyncService/RegisterSync",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: RegisterSyncRequest): Buffer =>
			Buffer.from(RegisterSyncRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): RegisterSyncRequest => RegisterSyncRequest.decode(value),
		responseSerialize: (value: RegisterSyncResponse): Buffer =>
			Buffer.from(RegisterSyncResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): RegisterSyncResponse => RegisterSyncResponse.decode(value),
	},
	/** Unregister project sync */
	unregisterSync: {
		path: "/codebase_syncer.SyncService/UnregisterSync",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: UnregisterSyncRequest): Buffer =>
			Buffer.from(UnregisterSyncRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): UnregisterSyncRequest => UnregisterSyncRequest.decode(value),
		responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
		responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
	},
	/** Share AccessToken (transmitted in plaintext, server-side encrypted storage) */
	shareAccessToken: {
		path: "/codebase_syncer.SyncService/ShareAccessToken",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: ShareAccessTokenRequest): Buffer =>
			Buffer.from(ShareAccessTokenRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): ShareAccessTokenRequest => ShareAccessTokenRequest.decode(value),
		responseSerialize: (value: ShareAccessTokenResponse): Buffer =>
			Buffer.from(ShareAccessTokenResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): ShareAccessTokenResponse => ShareAccessTokenResponse.decode(value),
	},
	/** Get application name and version info */
	getVersion: {
		path: "/codebase_syncer.SyncService/GetVersion",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: VersionRequest): Buffer => Buffer.from(VersionRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): VersionRequest => VersionRequest.decode(value),
		responseSerialize: (value: VersionResponse): Buffer => Buffer.from(VersionResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): VersionResponse => VersionResponse.decode(value),
	},
} as const

export interface SyncServiceServer extends UntypedServiceImplementation {
	/** Register project sync */
	registerSync: handleUnaryCall<RegisterSyncRequest, RegisterSyncResponse>
	/** Unregister project sync */
	unregisterSync: handleUnaryCall<UnregisterSyncRequest, Empty>
	/** Share AccessToken (transmitted in plaintext, server-side encrypted storage) */
	shareAccessToken: handleUnaryCall<ShareAccessTokenRequest, ShareAccessTokenResponse>
	/** Get application name and version info */
	getVersion: handleUnaryCall<VersionRequest, VersionResponse>
}

export interface SyncServiceClient extends Client {
	/** Register project sync */
	registerSync(
		request: RegisterSyncRequest,
		callback: (error: ServiceError | null, response: RegisterSyncResponse) => void,
	): ClientUnaryCall
	registerSync(
		request: RegisterSyncRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: RegisterSyncResponse) => void,
	): ClientUnaryCall
	registerSync(
		request: RegisterSyncRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: RegisterSyncResponse) => void,
	): ClientUnaryCall
	/** Unregister project sync */
	unregisterSync(
		request: UnregisterSyncRequest,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall
	unregisterSync(
		request: UnregisterSyncRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall
	unregisterSync(
		request: UnregisterSyncRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall
	/** Share AccessToken (transmitted in plaintext, server-side encrypted storage) */
	shareAccessToken(
		request: ShareAccessTokenRequest,
		callback: (error: ServiceError | null, response: ShareAccessTokenResponse) => void,
	): ClientUnaryCall
	shareAccessToken(
		request: ShareAccessTokenRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: ShareAccessTokenResponse) => void,
	): ClientUnaryCall
	shareAccessToken(
		request: ShareAccessTokenRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: ShareAccessTokenResponse) => void,
	): ClientUnaryCall
	/** Get application name and version info */
	getVersion(
		request: VersionRequest,
		callback: (error: ServiceError | null, response: VersionResponse) => void,
	): ClientUnaryCall
	getVersion(
		request: VersionRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: VersionResponse) => void,
	): ClientUnaryCall
	getVersion(
		request: VersionRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: VersionResponse) => void,
	): ClientUnaryCall
}

export const SyncServiceClient = makeGenericClientConstructor(
	SyncServiceService,
	"codebase_syncer.SyncService",
) as unknown as {
	new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SyncServiceClient
	service: typeof SyncServiceService
	serviceName: string
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function isSet(value: any): boolean {
	return value !== null && value !== undefined
}

export interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter
	decode(input: BinaryReader | Uint8Array, length?: number): T
	fromJSON(object: any): T
	toJSON(message: T): unknown
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
